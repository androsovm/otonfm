//
//  ContentView.swift
//  Oton.FM
//
//  Created by Yuri on 23/04/2025.
//

import SwiftUI
import AVFoundation
import MediaPlayer
import UIKit
import CoreHaptics

class RadioPlayer: NSObject, ObservableObject {
    static let shared = RadioPlayer()
    private var player: AVPlayer?
    private let defaultArtwork = UIImage(named: "defaultArtwork") // –ò—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞—Å—Ç–∞–≤–∫–∏ –±–µ–∑ –æ–±—Ä–∞–±–æ—Ç–∫–∏
    @Published var isPlaying = false
    @Published var currentTrackTitle: String = ""
    @Published var artworkImage: UIImage
    @Published var artworkId: UUID = UUID() // –î–æ–±–∞–≤–ª—è–µ–º ID –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
    @Published var isConnecting: Bool = false
    @Published var isBuffering: Bool = false // –ù–æ–≤–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–∏
    private var hasLoadedArtworkOnce = false
    private var artworkLoadingTask: URLSessionDataTask?
    private var lastTrackTitle: String = ""
    private var retryCount = 0
    private let maxRetries = 3
    private var bufferObservers: [NSKeyValueObservation] = []
    private var bufferingRestartWorkItem: DispatchWorkItem? = nil
    private var autoRestartAttempts = 0
    private let maxAutoRestartAttempts = 3
    private let bufferingTimeout: TimeInterval = 8.0

    private override init() {
        // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é –¥–µ—Ñ–æ–ª—Ç–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ –¥–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É —á—Ç–æ–±—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–∞–ª–∏—Å—å —É–≥–ª—ã
        if let defaultImg = UIImage(named: "defaultArtwork") {
            let renderer = UIGraphicsImageRenderer(size: defaultImg.size)
            let roundedImage = renderer.image { context in
                let rect = CGRect(origin: .zero, size: defaultImg.size)
                let path = UIBezierPath(roundedRect: rect, cornerRadius: defaultImg.size.width * 0.062) // ~16 –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è 260x260
                path.addClip()
                defaultImg.draw(in: rect)
            }
            self.artworkImage = roundedImage
        } else {
            self.artworkImage = UIImage()
        }
        super.init()
    }

    func playStream() {
        isConnecting = true
        guard let url = URL(string: "https://s4.radio.co/s696f24a77/listen") else { return }
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            print("Failed to set up audio session: \(error)")
        }
        player = AVPlayer(url: url)
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –±—É—Ñ–µ—Ä–∞: 20 —Å–µ–∫—É–Ω–¥
        player?.currentItem?.preferredForwardBufferDuration = 20
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª–∏
        bufferObservers.forEach { $0.invalidate() }
        bufferObservers.removeAll()
        // –î–æ–±–∞–≤–ª—è–µ–º KVO –Ω–∞ –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—é
        if let item = player?.currentItem {
            let obs1 = item.observe(\AVPlayerItem.isPlaybackBufferEmpty, options: [.new, .initial]) { [weak self] item, change in
                DispatchQueue.main.async {
                    if item.isPlaybackBufferEmpty {
                        self?.isBuffering = true
                        print("[Buffer] –ë—É—Ñ–µ—Ä –ø—É—Å—Ç, –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è...")
                        self?.scheduleBufferingRestart()
                    }
                }
            }
            let obs2 = item.observe(\AVPlayerItem.isPlaybackLikelyToKeepUp, options: [.new, .initial]) { [weak self] item, change in
                DispatchQueue.main.async {
                    if item.isPlaybackLikelyToKeepUp {
                        self?.isBuffering = false
                        print("[Buffer] –ë—É—Ñ–µ—Ä –Ω–∞–ø–æ–ª–Ω–µ–Ω, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ.")
                        self?.cancelBufferingRestart()
                        self?.autoRestartAttempts = 0 // –°–±—Ä–æ—Å –ø–æ–ø—ã—Ç–æ–∫ –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏
                    }
                }
            }
            bufferObservers.append(contentsOf: [obs1, obs2])
        }
        player?.currentItem?.addObserver(self, forKeyPath: "timedMetadata", options: [.new, .initial], context: nil)
        player?.play()
        fetchArtworkFromStatusAPI()
        setupNowPlaying()
        setupRemoteCommandCenter()
        
        // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ isPlaying –≤ true –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
        // —á—Ç–æ–±—ã –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø—É–ª—å—Å–∞—Ü–∏—é —Å—Ä–∞–∑—É
        DispatchQueue.main.async {
            self.isPlaying = true
        }
    }

    private func fetchArtworkFromStatusAPI() {
        let statusURL = URL(string: "https://public.radio.co/stations/s696f24a77/status")!
        var request = URLRequest(url: statusURL)
        request.cachePolicy = .reloadIgnoringLocalCacheData
        request.timeoutInterval = 15 // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç –¥–æ 10 —Å–µ–∫—É–Ω–¥
        
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é –±–µ–∑ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
        let config = URLSessionConfiguration.default
        config.requestCachePolicy = .reloadIgnoringLocalCacheData
        config.urlCache = nil
        config.timeoutIntervalForRequest = 10
        config.timeoutIntervalForResource = 10
        let session = URLSession(configuration: config)
        
        // –û—Ç–º–µ–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é –∑–∞–¥–∞—á—É, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
        artworkLoadingTask?.cancel()
        
        artworkLoadingTask = session.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            if let error = error {
                print("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞: \(error.localizedDescription)")
                return
            }
            
            guard let data = data else {
                print("‚ö†Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö —Å—Ç–∞—Ç—É—Å–∞")
                return
            }
            
            print("üß© –ü–æ–ª—É—á–µ–Ω—ã –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –æ —Ç—Ä–µ–∫–µ")
            
            guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let current = json["current_track"] as? [String: Any],
                  let artworkURLString = current["artwork_url_large"] as? String else {
                print("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å URL –æ–±–ª–æ–∂–∫–∏")
                return
            }

            print("üé® –ü–æ–ª—É—á–µ–Ω artwork URL: \(artworkURLString)")
            
            // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –¥–æ–±–∞–≤–ª—è–µ–º timestamp –∫ URL –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
            let timestamp = Date().timeIntervalSince1970
            let cacheBustingURLString = "\(artworkURLString)?nocache=\(timestamp)"
            guard let imageURL = URL(string: cacheBustingURLString) else {
                print("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π URL –æ–±–ª–æ–∂–∫–∏")
                return
            }
            
            print("üîÑ –ó–∞–ø—Ä–æ—Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: \(cacheBustingURLString)")
            
            // –ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –±–µ–∑ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
            var imageRequest = URLRequest(url: imageURL)
            imageRequest.cachePolicy = .reloadIgnoringLocalCacheData
            imageRequest.addValue("no-cache", forHTTPHeaderField: "Cache-Control")
            imageRequest.timeoutInterval = 10
            
            let imageTask = session.dataTask(with: imageRequest) { [weak self] imageData, imageResponse, imageError in
                guard let self = self else { return }
                
                print("üì∑ –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
                
                if let error = imageError {
                    print("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: \(error.localizedDescription)")
                    
                    if self.retryCount < self.maxRetries {
                        self.retryCount += 1
                        print("üîÑ –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ (\(self.retryCount)/\(self.maxRetries))")
                        
                        let delay = Double(self.retryCount) * 2.0
                        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                            self.fetchArtworkFromStatusAPI()
                        }
                    } else {
                        print("‚ö†Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏")
                        self.retryCount = 0
                    }
                    return
                }
                
                guard let imageData = imageData, !imageData.isEmpty else {
                    print("‚ö†Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
                    return
                }
                
                if let image = UIImage(data: imageData) {
                    DispatchQueue.main.async {
                        print("üìä –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ URL –æ–±–ª–æ–∂–∫–∏: \(artworkURLString)")
                        let isStationLogo = artworkURLString.contains("station_logos") || artworkURLString.contains("s696f24a77") || artworkURLString.lowercased().contains("oton")
                        print("üîç –≠—Ç–æ –ª–æ–≥–æ—Ç–∏–ø —Å—Ç–∞–Ω—Ü–∏–∏? \(isStationLogo ? "–î–∞" : "–ù–µ—Ç")")
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±–ª–æ–∂–∫—É –≤ –ª—é–±–æ–º —Å–ª—É—á–∞–µ
                        self.setTrackArtwork(image)
                        self.retryCount = 0
                    }
                }
            }
            imageTask.resume()
        }
        artworkLoadingTask?.resume()
    }

    private func setDefaultArtwork() {
        DispatchQueue.main.async {
            if let defaultImg = self.defaultArtwork {
                let renderer = UIGraphicsImageRenderer(size: defaultImg.size)
                let roundedImage = renderer.image { context in
                    let rect = CGRect(origin: .zero, size: defaultImg.size)
                    let path = UIBezierPath(roundedRect: rect, cornerRadius: defaultImg.size.width * 0.062)
                    path.addClip()
                    defaultImg.draw(in: rect)
                }
                self.artworkImage = roundedImage
                self.artworkId = UUID()
                
                let artwork = MPMediaItemArtwork(boundsSize: roundedImage.size) { _ in roundedImage }
                MPNowPlayingInfoCenter.default().nowPlayingInfo?[MPMediaItemPropertyArtwork] = artwork
                print("üéµ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–µ—Ñ–æ–ª—Ç–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ")
            }
        }
    }
    
    private func setTrackArtwork(_ image: UIImage) {
        DispatchQueue.main.async {
            let renderer = UIGraphicsImageRenderer(size: image.size)
            let roundedImage = renderer.image { context in
                let rect = CGRect(origin: .zero, size: image.size)
                let path = UIBezierPath(roundedRect: rect, cornerRadius: image.size.width * 0.062)
                path.addClip()
                image.draw(in: rect)
            }
            
            self.artworkImage = roundedImage
            self.artworkId = UUID()
            print("üÜî –ù–æ–≤—ã–π ID –æ–±–ª–æ–∂–∫–∏: \(self.artworkId)")
            
            let artwork = MPMediaItemArtwork(boundsSize: roundedImage.size) { _ in roundedImage }
            MPNowPlayingInfoCenter.default().nowPlayingInfo?[MPMediaItemPropertyArtwork] = artwork
            print("üéµ –û–±–Ω–æ–≤–ª–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞")
        }
    }

    func pause() {
        player?.pause()
        isPlaying = false
        isBuffering = false
        cancelBufferingRestart()
    }

    private func setupNowPlaying() {
        let image = self.artworkImage
        let artwork = MPMediaItemArtwork(boundsSize: image.size) { _ in image }

        let nowPlayingInfo: [String: Any] = [
            MPMediaItemPropertyTitle: currentTrackTitle.isEmpty ? "Oton.FM Radio" : currentTrackTitle,
            MPMediaItemPropertyArtist: "Live Stream",
            MPMediaItemPropertyArtwork: artwork
        ]
        MPNowPlayingInfoCenter.default().nowPlayingInfo = nowPlayingInfo
    }

    private func setupRemoteCommandCenter() {
        let commandCenter = MPRemoteCommandCenter.shared()

        commandCenter.playCommand.addTarget { [weak self] _ in
            self?.playStream()
            return .success
        }

        commandCenter.pauseCommand.addTarget { [weak self] _ in
            self?.pause()
            return .success
        }

        commandCenter.playCommand.isEnabled = true
        commandCenter.pauseCommand.isEnabled = true
    }

    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == "timedMetadata",
           let metadataItems = player?.currentItem?.timedMetadata {
            for item in metadataItems {
                if let value = item.value as? String {
                    print("üìå –ù–æ–≤—ã–π —Ç—Ä–µ–∫: \(value)")
                    DispatchQueue.main.async {
                        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç—Ä–µ–∫ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
                        let previousTrack = self.currentTrackTitle
                        let isNewTrack = previousTrack != value
                        
                        self.currentTrackTitle = value
                        self.isConnecting = false
                        self.isPlaying = true
                        MPNowPlayingInfoCenter.default().nowPlayingInfo?[MPMediaItemPropertyTitle] = value
                        
                        // –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±–ª–æ–∂–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω–æ–≤—ã–π —Ç—Ä–µ–∫
                        if isNewTrack {
                            print("üÜï –û–±–Ω–∞—Ä—É–∂–µ–Ω –Ω–æ–≤—ã–π —Ç—Ä–µ–∫: \(value), –ø—Ä–µ–¥—ã–¥—É—â–∏–π: \(previousTrack)")
                            
                            // –û—Ç–º–µ–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é –∑–∞–¥–∞—á—É –∑–∞–≥—Ä—É–∑–∫–∏, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
                            self.artworkLoadingTask?.cancel()
                            
                            // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –Ω–æ–≤—É—é –æ–±–ª–æ–∂–∫—É
                            print("üîÑ –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –æ–±–ª–æ–∂–∫—É –¥–ª—è —Ç—Ä–µ–∫–∞: \(value)")
                            self.fetchArtworkFromStatusAPI()
                        } else {
                            print("‚ÑπÔ∏è –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Ç–æ–º –∂–µ —Ç—Ä–µ–∫–µ: \(value)")
                        }
                    }
                }
            }
        }
    }

    private func scheduleBufferingRestart() {
        cancelBufferingRestart()
        guard autoRestartAttempts < maxAutoRestartAttempts else {
            print("[Buffer] –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø–æ–ø—ã—Ç–æ–∫ —Ä–µ—Å—Ç–∞—Ä—Ç–∞ –ø–æ—Ç–æ–∫–∞.")
            return
        }
        let workItem = DispatchWorkItem { [weak self] in
            guard let self = self else { return }
            if self.isBuffering {
                self.autoRestartAttempts += 1
                print("[Buffer] –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ—Å—Ç–∞—Ä—Ç –ø–æ—Ç–æ–∫–∞ (–ø–æ–ø—ã—Ç–∫–∞ \(self.autoRestartAttempts)/\(self.maxAutoRestartAttempts))...")
                self.player?.pause()
                self.playStream()
            }
        }
        bufferingRestartWorkItem = workItem
        DispatchQueue.main.asyncAfter(deadline: .now() + bufferingTimeout, execute: workItem)
    }

    private func cancelBufferingRestart() {
        bufferingRestartWorkItem?.cancel()
        bufferingRestartWorkItem = nil
    }

    deinit {
        bufferObservers.forEach { $0.invalidate() }
        bufferObservers.removeAll()
        cancelBufferingRestart()
    }
}

struct SplashView: View {
    @State private var animate = false
    @Binding var isActive: Bool

    var body: some View {
        ZStack {
            Color.white.ignoresSafeArea()

            Image("otonLogo")
                .resizable()
                .scaledToFit()
                .frame(width: 120, height: 120)
                .scaleEffect(animate ? 1.2 : 0.8)
                .opacity(animate ? 0 : 1)
                .animation(.easeInOut(duration: 1.5), value: animate)
        }
        .onAppear {
            animate = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                isActive = false
            }
        }
    }
}

struct ContentView: View {
    @StateObject private var player = RadioPlayer.shared
    @State private var isInterfaceVisible = false
    @State private var isPressed = false
    @State private var pulsateAnimation = false
    @State private var hapticEngine: CHHapticEngine?
    
    var body: some View {
        ZStack {
            Image(uiImage: player.artworkImage)
                .resizable()
                .scaledToFill()
                .blur(radius: 50)
                .opacity(0.4)
                .ignoresSafeArea()
                .animation(.easeInOut(duration: 0.5), value: player.artworkId)

            if isInterfaceVisible {
                VStack(spacing: 20) {
                    Image("otonLogo")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 120, height: 120)
                        .padding(.bottom, -10)

                    Image(uiImage: player.artworkImage)
                        .resizable()
                        .scaledToFit()
                        .frame(width: 300, height: 300)
                        .clipShape(RoundedRectangle(cornerRadius: 16))
                        .shadow(color: Color(player.artworkImage.averageColor ?? .black).opacity(0.5), radius: 20, x: 0, y: 10)
                        .scaleEffect(player.isPlaying && pulsateAnimation ? 1.02 : 1.0)
                        .animation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true), value: pulsateAnimation)
                        .opacity(1.0)
                        .animation(.easeInOut(duration: 0.5), value: player.artworkId)

                    Group {
                        if player.isConnecting {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: player.artworkImage.averageColor?.isLightColor == true ? .black : .white))
                                .frame(height: 50)
                        } else {
                            Text(player.currentTrackTitle)
                                .id(player.currentTrackTitle)
                                .font(.headline)
                                .foregroundColor(player.artworkImage.averageColor?.isLightColor == true ? .black : .white)
                                .lineLimit(2)
                                .multilineTextAlignment(.center)
                                .fixedSize(horizontal: false, vertical: true)
                                .frame(maxWidth: .infinity)
                                .frame(minHeight: 50)
                                .padding(.horizontal)
                                .transition(.opacity)
                                .animation(.easeInOut(duration: 0.5), value: player.currentTrackTitle)
                        }
                    }

                    Button(action: {
                        playComplexHaptic()
                        
                        if player.isPlaying {
                            player.pause()
                        } else {
                            player.playStream()
                        }
                        pulsateAnimation = player.isPlaying
                    }) {
                        ZStack {
                            Circle()
                                .fill(Color(player.artworkImage.averageColor ?? .white).opacity(0.5))
                                .blur(radius: 20)
                                .frame(width: 120, height: 120)
                                .scaleEffect(player.isPlaying ? 1.3 : 1.0)
                                .animation(.easeInOut(duration: 3.0).repeatForever(autoreverses: true), value: player.isPlaying)
                            
                            Image(systemName: player.isPlaying ? "pause.circle.fill" : "play.circle.fill")
                                .resizable()
                                .symbolRenderingMode(.palette)
                                .foregroundStyle(.white, Color(red: 208/255, green: 0, blue: 0))
                                .frame(width: 80, height: 80)
                                .shadow(color: Color(red: 208/255, green: 0, blue: 0).opacity(0.6), radius: 15, x: 0, y: 0)
                                .scaleEffect(isPressed ? 0.85 : 1.0)
                                .animation(.easeOut(duration: 0.2), value: isPressed)
                        }
                    }
                    .buttonStyle(.plain)
                    .simultaneousGesture(
                        DragGesture(minimumDistance: 0)
                            .onChanged { _ in 
                                isPressed = true
                                playHapticFeedback(.light)
                            }
                            .onEnded { _ in 
                                isPressed = false
                                playHapticFeedback(.light)
                            }
                    )
                }
                .padding()
                .transition(.opacity)
                .animation(.easeInOut(duration: 1.0), value: isInterfaceVisible)
            }
        }
        .onAppear {
            withAnimation {
                isInterfaceVisible = true
            }
            pulsateAnimation = player.isPlaying
        }
        .onChange(of: player.isPlaying) { isPlaying in
            pulsateAnimation = isPlaying
        }
        .onChange(of: player.currentTrackTitle) { _ in
            playHapticFeedback(.medium)
        }
        .onAppear(perform: prepareHaptics)
    }
    
    // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º haptic engine
    private func prepareHaptics() {
        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }
        
        do {
            hapticEngine = try CHHapticEngine()
            try hapticEngine?.start()
        } catch {
            print("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ haptic engine: \(error.localizedDescription)")
        }
    }
    
    // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –ø—Ä–æ—Å—Ç–æ–π —Ç–∞–∫—Ç–∏–ª—å–Ω—ã–π –æ—Ç–∫–ª–∏–∫
    private func playHapticFeedback(_ style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω —Ç–∞–∫—Ç–∏–ª—å–Ω–æ–≥–æ –æ—Ç–∫–ª–∏–∫–∞
    private func playComplexHaptic() {
        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics,
              let engine = hapticEngine else { return }
        
        // –°–æ–∑–¥–∞–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Å–æ–±—ã—Ç–∏—è
        let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1.0)
        let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.7)
        
        // –°–æ–∑–¥–∞–µ–º —Å–æ–±—ã—Ç–∏—è
        let event1 = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0)
        let event2 = CHHapticEvent(eventType: .hapticContinuous, parameters: [
            CHHapticEventParameter(parameterID: .hapticIntensity, value: 0.5),
            CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.5)
        ], relativeTime: 0.1, duration: 0.2)
        
        do {
            let pattern = try CHHapticPattern(events: [event1, event2], parameters: [])
            let player = try engine.makePlayer(with: pattern)
            try player.start(atTime: 0)
        } catch {
            print("–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ —Ç–∞–∫—Ç–∏–ª—å–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω: \(error.localizedDescription)")
        }
    }
}

extension UIImage {
    var averageColor: UIColor? {
        guard let inputImage = CIImage(image: self) else { return nil }
        let extent = inputImage.extent
        let context = CIContext(options: [.workingColorSpace: kCFNull!])
        let parameters = [kCIInputExtentKey: CIVector(cgRect: extent)]
        guard let filter = CIFilter(name: "CIAreaAverage", parameters: parameters) else { return nil }
        filter.setValue(inputImage, forKey: kCIInputImageKey)
        guard let outputImage = filter.outputImage else { return nil }

        var bitmap = [UInt8](repeating: 0, count: 4)
        context.render(outputImage,
                       toBitmap: &bitmap,
                       rowBytes: 4,
                       bounds: CGRect(x: 0, y: 0, width: 1, height: 1),
                       format: .RGBA8,
                       colorSpace: nil)

        return UIColor(red: CGFloat(bitmap[0]) / 255,
                       green: CGFloat(bitmap[1]) / 255,
                       blue: CGFloat(bitmap[2]) / 255,
                       alpha: CGFloat(bitmap[3]) / 255)
    }
}

extension UIColor {
    var isLightColor: Bool {
        var white: CGFloat = 0
        getWhite(&white, alpha: nil)
        return white > 0.7
    }
}


